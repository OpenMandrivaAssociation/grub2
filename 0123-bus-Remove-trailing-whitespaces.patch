From b3897585dd9e92890937fb233347b4f2a7277a8e Mon Sep 17 00:00:00 2001
From: Elyes Haouas <ehaouas@noos.fr>
Date: Fri, 4 Mar 2022 07:41:55 +0100
Subject: [PATCH 123/261] bus: Remove trailing whitespaces

Signed-off-by: Elyes Haouas <ehaouas@noos.fr>
Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
---
 grub-core/bus/bonito.c            | 22 ++++++-------
 grub-core/bus/cs5536.c            | 22 ++++++-------
 grub-core/bus/pci.c               |  4 +--
 grub-core/bus/usb/ehci-pci.c      |  6 ++--
 grub-core/bus/usb/ehci.c          |  8 ++---
 grub-core/bus/usb/ohci.c          | 54 +++++++++++++++----------------
 grub-core/bus/usb/serial/common.c |  2 +-
 grub-core/bus/usb/serial/ftdi.c   |  2 +-
 grub-core/bus/usb/serial/pl2303.c |  2 +-
 grub-core/bus/usb/uhci.c          | 32 +++++++++---------
 grub-core/bus/usb/usb.c           |  6 ++--
 grub-core/bus/usb/usbhub.c        | 20 ++++++------
 grub-core/bus/usb/usbtrans.c      |  4 +--
 13 files changed, 92 insertions(+), 92 deletions(-)

diff --git a/grub-core/bus/bonito.c b/grub-core/bus/bonito.c
index 9a63f073c..23b9a9915 100644
--- a/grub-core/bus/bonito.c
+++ b/grub-core/bus/bonito.c
@@ -21,12 +21,12 @@
 #include <grub/misc.h>
 
 static grub_uint32_t base_win[GRUB_MACHINE_PCI_NUM_WIN];
-static const grub_size_t sizes_win[GRUB_MACHINE_PCI_NUM_WIN] = 
-  {GRUB_MACHINE_PCI_WIN1_SIZE, GRUB_MACHINE_PCI_WIN_SIZE, 
+static const grub_size_t sizes_win[GRUB_MACHINE_PCI_NUM_WIN] =
+  {GRUB_MACHINE_PCI_WIN1_SIZE, GRUB_MACHINE_PCI_WIN_SIZE,
    GRUB_MACHINE_PCI_WIN_SIZE};
 /* Usage counters.  */
 static int usage_win[GRUB_MACHINE_PCI_NUM_WIN];
-static grub_addr_t addr_win[GRUB_MACHINE_PCI_NUM_WIN] = 
+static grub_addr_t addr_win[GRUB_MACHINE_PCI_NUM_WIN] =
   {GRUB_MACHINE_PCI_WIN1_ADDR, GRUB_MACHINE_PCI_WIN2_ADDR,
    GRUB_MACHINE_PCI_WIN3_ADDR};
 
@@ -93,9 +93,9 @@ write_bases_2f (void)
 {
   int i;
   grub_uint32_t reg = 0;
-  for (i = 0; i < GRUB_MACHINE_PCI_NUM_WIN; i++) 
-    reg |= (((base_win[i] >> GRUB_MACHINE_PCI_WIN_SHIFT) 
-	     & GRUB_MACHINE_PCI_WIN_MASK) 
+  for (i = 0; i < GRUB_MACHINE_PCI_NUM_WIN; i++)
+    reg |= (((base_win[i] >> GRUB_MACHINE_PCI_WIN_SHIFT)
+	     & GRUB_MACHINE_PCI_WIN_MASK)
 	    << (i * GRUB_MACHINE_PCI_WIN_MASK_SIZE));
   GRUB_MACHINE_PCI_IO_CTRL_REG_2F = reg;
 }
@@ -111,23 +111,23 @@ grub_pci_device_map_range (grub_pci_device_t dev __attribute__ ((unused)),
 
       /* First try already used registers. */
       for (i = 0; i < GRUB_MACHINE_PCI_NUM_WIN; i++)
-	if (usage_win[i] && base_win[i] <= base 
+	if (usage_win[i] && base_win[i] <= base
 	    && base_win[i] + sizes_win[i] > base + size)
 	  {
 	    usage_win[i]++;
-	    return (void *) 
+	    return (void *)
 	      (addr_win[i] | (base & GRUB_MACHINE_PCI_WIN_OFFSET_MASK));
 	  }
       /* Map new register.  */
       newbase = base & ~GRUB_MACHINE_PCI_WIN_OFFSET_MASK;
       for (i = 0; i < GRUB_MACHINE_PCI_NUM_WIN; i++)
-	if (!usage_win[i] && newbase <= base 
+	if (!usage_win[i] && newbase <= base
 	    && newbase + sizes_win[i] > base + size)
 	  {
 	    usage_win[i]++;
 	    base_win[i] = newbase;
 	    write_bases_2f ();
-	    return (void *) 
+	    return (void *)
 	      (addr_win[i] | (base & GRUB_MACHINE_PCI_WIN_OFFSET_MASK));
 	  }
       grub_fatal ("Out of PCI windows.");
@@ -164,7 +164,7 @@ grub_pci_device_unmap_range (grub_pci_device_t dev __attribute__ ((unused)),
     {
       int i;
       for (i = 0; i < GRUB_MACHINE_PCI_NUM_WIN; i++)
-	if (usage_win[i] && addr_win[i] 
+	if (usage_win[i] && addr_win[i]
 	    == (((grub_addr_t) mem | 0x20000000)
 		& ~GRUB_MACHINE_PCI_WIN_OFFSET_MASK))
 	  {
diff --git a/grub-core/bus/cs5536.c b/grub-core/bus/cs5536.c
index bb9aa27e5..8c90ed598 100644
--- a/grub-core/bus/cs5536.c
+++ b/grub-core/bus/cs5536.c
@@ -72,7 +72,7 @@ grub_cs5536_read_msr (grub_pci_device_t dev, grub_uint32_t addr)
 		  addr);
   ret = (grub_uint64_t)
     grub_pci_read (grub_pci_make_address (dev, GRUB_CS5536_MSR_MAILBOX_DATA0));
-  ret |= (((grub_uint64_t) 
+  ret |= (((grub_uint64_t)
 	  grub_pci_read (grub_pci_make_address (dev,
 						GRUB_CS5536_MSR_MAILBOX_DATA1)))
 	  << 32);
@@ -100,7 +100,7 @@ grub_cs5536_smbus_wait (grub_port_t smbbase)
       grub_uint8_t status;
       status = grub_inb (smbbase + GRUB_CS5536_SMB_REG_STATUS);
       if (status & GRUB_CS5536_SMB_REG_STATUS_SDAST)
-	return GRUB_ERR_NONE;	
+	return GRUB_ERR_NONE;
       if (status & GRUB_CS5536_SMB_REG_STATUS_BER)
 	return grub_error (GRUB_ERR_IO, "SM bus error");
       if (status & GRUB_CS5536_SMB_REG_STATUS_NACK)
@@ -122,8 +122,8 @@ grub_cs5536_read_spd_byte (grub_port_t smbbase, grub_uint8_t dev,
 	     smbbase + GRUB_CS5536_SMB_REG_CTRL1);
 
   /* Send device address.  */
-  err = grub_cs5536_smbus_wait (smbbase); 
-  if (err) 
+  err = grub_cs5536_smbus_wait (smbbase);
+  if (err)
     return err;
   grub_outb (dev << 1, smbbase + GRUB_CS5536_SMB_REG_DATA);
 
@@ -139,8 +139,8 @@ grub_cs5536_read_spd_byte (grub_port_t smbbase, grub_uint8_t dev,
   grub_outb (addr, smbbase + GRUB_CS5536_SMB_REG_DATA);
 
   /* Send START.  */
-  err = grub_cs5536_smbus_wait (smbbase); 
-  if (err) 
+  err = grub_cs5536_smbus_wait (smbbase);
+  if (err)
     return err;
   grub_outb (grub_inb (smbbase + GRUB_CS5536_SMB_REG_CTRL1)
 	     | GRUB_CS5536_SMB_REG_CTRL1_START,
@@ -161,7 +161,7 @@ grub_cs5536_read_spd_byte (grub_port_t smbbase, grub_uint8_t dev,
 	     smbbase + GRUB_CS5536_SMB_REG_CTRL1);
 
   err = grub_cs5536_smbus_wait (smbbase);
-  if (err) 
+  if (err)
     return err;
   *res = grub_inb (smbbase + GRUB_CS5536_SMB_REG_DATA);
 
@@ -198,8 +198,8 @@ grub_cs5536_init_smbus (grub_pci_device_t dev, grub_uint16_t divisor,
   grub_outb (((divisor >> 7) & 0xff), *smbbase + GRUB_CS5536_SMB_REG_CTRL3);
   grub_outb (((divisor << 1) & 0xfe) | GRUB_CS5536_SMB_REG_CTRL2_ENABLE,
 	     *smbbase + GRUB_CS5536_SMB_REG_CTRL2);
-  
-  return GRUB_ERR_NONE; 
+
+  return GRUB_ERR_NONE;
 }
 
 grub_err_t
@@ -217,7 +217,7 @@ grub_cs5536_read_spd (grub_port_t smbbase, grub_uint8_t dev,
   if (b == 0)
     return grub_error (GRUB_ERR_IO, "no SPD found");
   size = b;
-  
+
   ((grub_uint8_t *) res)[0] = b;
   for (ptr = 1; ptr < size; ptr++)
     {
@@ -310,7 +310,7 @@ grub_cs5536_init_geode (grub_pci_device_t dev)
 
   /* Initialise USB controller.  */
   /* FIXME: assign adresses dynamically.  */
-  grub_cs5536_write_msr (dev, GRUB_CS5536_MSR_USB_OHCI_BASE, 
+  grub_cs5536_write_msr (dev, GRUB_CS5536_MSR_USB_OHCI_BASE,
 			 GRUB_CS5536_MSR_USB_BASE_BUS_MASTER
 			 | GRUB_CS5536_MSR_USB_BASE_MEMORY_ENABLE
 			 | 0x05024000);
diff --git a/grub-core/bus/pci.c b/grub-core/bus/pci.c
index b388ce5c8..c1ee9dc58 100644
--- a/grub-core/bus/pci.c
+++ b/grub-core/bus/pci.c
@@ -159,12 +159,12 @@ grub_pci_find_capability (grub_pci_device_t dev, grub_uint8_t cap)
 
       pos &= ~3;
 
-      addr = grub_pci_make_address (dev, pos);      
+      addr = grub_pci_make_address (dev, pos);
       id = grub_pci_read_byte (addr);
 
       if (id == 0xff)
 	break;
-      
+
       if (id == cap)
 	return pos;
       pos++;
diff --git a/grub-core/bus/usb/ehci-pci.c b/grub-core/bus/usb/ehci-pci.c
index 65e6cb574..aa04988fd 100644
--- a/grub-core/bus/usb/ehci-pci.c
+++ b/grub-core/bus/usb/ehci-pci.c
@@ -96,7 +96,7 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 	  return 0;
 	}
       grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: bus rev. num. OK\n");
-  
+
       /* Determine EHCI EHCC registers base address.  */
       addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESS_REG0);
       base = grub_pci_read (addr);
@@ -125,7 +125,7 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 			  GRUB_PCI_COMMAND_MEM_ENABLED
 			  | GRUB_PCI_COMMAND_BUS_MASTER
 			  | grub_pci_read_word(addr));
-      
+
       grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: 32-bit EHCI OK\n");
     }
 
@@ -142,7 +142,7 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
     /* Determine and change ownership. */
   /* EECP offset valid in HCCPARAMS */
   /* Ownership can be changed via EECP only */
-  if (pciid != GRUB_CS5536_PCIID && eecp_offset >= 0x40)	
+  if (pciid != GRUB_CS5536_PCIID && eecp_offset >= 0x40)
     {
       grub_pci_address_t pciaddr_eecp;
       pciaddr_eecp = grub_pci_make_address (dev, eecp_offset);
diff --git a/grub-core/bus/usb/ehci.c b/grub-core/bus/usb/ehci.c
index d966fc210..9abebc6bd 100644
--- a/grub-core/bus/usb/ehci.c
+++ b/grub-core/bus/usb/ehci.c
@@ -498,8 +498,8 @@ grub_ehci_init_device (volatile void *regs)
     }
   e->iobase = ((volatile grub_uint32_t *) e->iobase_ehcc
 	       + (caplen / sizeof (grub_uint32_t)));
-#else  
-  e->iobase = (volatile grub_uint32_t *) 
+#else
+  e->iobase = (volatile grub_uint32_t *)
     ((grub_uint8_t *) e->iobase_ehcc + caplen);
 #endif
 
@@ -869,7 +869,7 @@ grub_ehci_find_qh (struct grub_ehci *e, grub_usb_transfer_t transfer)
     i++ )
     {
       if (target == (qh_iter->ep_char & mask))
-	{		
+	{
 	  /* Found proper existing (and linked) QH, do setup of QH */
 	  grub_dprintf ("ehci", "find_qh: found, QH=%p\n", qh_iter);
 	  grub_ehci_setup_qh (qh_iter, transfer);
@@ -1813,7 +1813,7 @@ static struct grub_usb_controller_dev usb_controller = {
   .portstatus = grub_ehci_portstatus,
   .detect_dev = grub_ehci_detect_dev,
   /* estimated max. count of TDs for one bulk transfer */
-  .max_bulk_tds = GRUB_EHCI_N_TD * 3 / 4 
+  .max_bulk_tds = GRUB_EHCI_N_TD * 3 / 4
 };
 
 GRUB_MOD_INIT (ehci)
diff --git a/grub-core/bus/usb/ohci.c b/grub-core/bus/usb/ohci.c
index f0be533d4..5363a61f6 100644
--- a/grub-core/bus/usb/ohci.c
+++ b/grub-core/bus/usb/ohci.c
@@ -196,7 +196,7 @@ grub_ohci_td_virt2phys (struct grub_ohci *o,  grub_ohci_td_t x)
   return (grub_uint8_t *)x - (grub_uint8_t *)o->td + o->td_addr;
 }
 
-  
+
 static grub_uint32_t
 grub_ohci_readreg32 (struct grub_ohci *o, grub_ohci_reg_t reg)
 {
@@ -224,7 +224,7 @@ grub_ohci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
   struct grub_ohci *o;
   grub_uint32_t revision;
   int j;
-  
+
   /* Determine IO base address.  */
   grub_dprintf ("ohci", "pciid = %x\n", pciid);
 
@@ -253,7 +253,7 @@ grub_ohci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 
       addr = grub_pci_make_address (dev, GRUB_PCI_REG_CLASS);
       class_code = grub_pci_read (addr) >> 8;
-      
+
       interf = class_code & 0xFF;
       subclass = (class_code >> 8) & 0xFF;
       class = class_code >> 16;
@@ -315,7 +315,7 @@ grub_ohci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 	       * GRUB_OHCI_CTRL_EDS);
   for (j=0; j < GRUB_OHCI_CTRL_EDS; j++)
     o->ed_ctrl[j].target = grub_cpu_to_le32_compile_time (1 << 14); /* skip */
-    
+
   grub_dprintf ("ohci", "EDs-C: chunk=%p, virt=%p, phys=0x%02x\n",
                 o->ed_ctrl_chunk, o->ed_ctrl, o->ed_ctrl_addr);
 
@@ -385,7 +385,7 @@ grub_ohci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 	    grub_dprintf("ohci", "Ownership changing timeout, change forced !\n");
 	  }
       }
-    else if (((control & 0x100) == 0) && 
+    else if (((control & 0x100) == 0) &&
 	     ((control & 0xc0) != 0)) /* Not owned by SMM nor reset */
       {
 	grub_dprintf("ohci", "OHCI is owned by BIOS\n");
@@ -396,7 +396,7 @@ grub_ohci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
       {
 	grub_dprintf("ohci", "OHCI is not owned by SMM nor BIOS\n");
 	/* We can setup OHCI. */
-      }  
+      }
   }
 
   /* Suspend the OHCI by issuing a reset.  */
@@ -513,7 +513,7 @@ grub_ohci_find_ed (struct grub_ohci *o, int bulk, grub_uint32_t target)
 
   /* Use proper values and structures. */
   if (bulk)
-    {    
+    {
       count = GRUB_OHCI_BULK_EDS;
       ed = o->ed_bulk;
       ed_next = grub_ohci_ed_phys2virt(o, bulk,
@@ -576,7 +576,7 @@ grub_ohci_alloc_td (struct grub_ohci *o)
 static void
 grub_ohci_free_td (struct grub_ohci *o, grub_ohci_td_t td)
 {
-  grub_memset ( (void*)td, 0, sizeof(struct grub_ohci_td) ); 
+  grub_memset ( (void*)td, 0, sizeof(struct grub_ohci_td) );
   td->link_td = o->td_free; /* Cahin new free TD & rest */
   o->td_free = td; /* Change address of first free TD */
 }
@@ -586,7 +586,7 @@ grub_ohci_free_tds (struct grub_ohci *o, grub_ohci_td_t td)
 {
   if (!td)
     return;
-    
+
   /* Unchain first TD from previous TD if it is chained */
   if (td->prev_td_phys)
     {
@@ -596,12 +596,12 @@ grub_ohci_free_tds (struct grub_ohci *o, grub_ohci_td_t td)
       if (td == (grub_ohci_td_t) td_prev_virt->link_td)
         td_prev_virt->link_td = 0;
     }
-  
+
   /* Free all TDs from td  (chained by link_td) */
   while (td)
     {
       grub_ohci_td_t tdprev;
-      
+
       /* Unlink the queue.  */
       tdprev = td;
       td = (grub_ohci_td_t) td->link_td;
@@ -658,7 +658,7 @@ grub_ohci_transaction (grub_ohci_td_t td,
       td->buffer = grub_cpu_to_le32 (buffer);
       td->buffer_end = grub_cpu_to_le32 (buffer_end);
     }
-  else 
+  else
     {
       td->buffer = 0;
       td->buffer_end = 0;
@@ -728,7 +728,7 @@ grub_ohci_setup_transfer (grub_usb_controller_t dev,
       grub_free (cdata);
       return GRUB_USB_ERR_INTERNAL;
     }
-  
+
   /* Take pointer to first TD from ED */
   td_head_phys = grub_le_to_cpu32 (cdata->ed_virt->td_head) & ~0xf;
   td_tail_phys = grub_le_to_cpu32 (cdata->ed_virt->td_tail) & ~0xf;
@@ -743,7 +743,7 @@ grub_ohci_setup_transfer (grub_usb_controller_t dev,
       grub_free (cdata);
       return GRUB_USB_ERR_INTERNAL;
     }
-  
+
   /* Now we should handle first TD. If ED is newly allocated,
    * we must allocate the first TD. */
   if (!td_head_phys)
@@ -762,7 +762,7 @@ grub_ohci_setup_transfer (grub_usb_controller_t dev,
     }
   else
     cdata->td_head_virt = grub_ohci_td_phys2virt ( o, td_head_phys );
-    
+
   /* Set TDs */
   cdata->td_last_phys = td_head_phys; /* initial value to make compiler happy... */
   for (i = 0, cdata->td_current_virt = cdata->td_head_virt;
@@ -775,10 +775,10 @@ grub_ohci_setup_transfer (grub_usb_controller_t dev,
 
       /* Set index of TD in transfer */
       cdata->td_current_virt->tr_index = (grub_uint32_t) i;
-      
+
       /* Remember last used (processed) TD phys. addr. */
       cdata->td_last_phys = grub_ohci_td_virt2phys (o, cdata->td_current_virt);
-      
+
       /* Allocate next TD */
       td_next_virt = grub_ohci_alloc_td (o);
       if (!td_next_virt) /* No free TD, cancel transfer and free TDs except head TD */
@@ -807,7 +807,7 @@ grub_ohci_setup_transfer (grub_usb_controller_t dev,
 
   grub_dprintf ("ohci", "Tail TD (not processed) = %p\n",
                 cdata->td_current_virt);
-  
+
   /* Setup the Endpoint Descriptor for transfer.  */
   /* First set necessary fields in TARGET but keep (or set) skip bit */
   /* Note: It could be simpler if speed, format and max. packet
@@ -923,7 +923,7 @@ finish_transfer (grub_usb_controller_t dev,
   struct grub_ohci_transfer_controller_data *cdata = transfer->controller_data;
 
   /* Set empty ED - set HEAD = TAIL = last (not processed) TD */
-  cdata->ed_virt->td_head = grub_cpu_to_le32 (grub_le_to_cpu32 (cdata->ed_virt->td_tail) & ~0xf); 
+  cdata->ed_virt->td_head = grub_cpu_to_le32 (grub_le_to_cpu32 (cdata->ed_virt->td_tail) & ~0xf);
 
   /* At this point always should be:
    * ED has skip bit set and halted or empty or after next SOF,
@@ -935,7 +935,7 @@ finish_transfer (grub_usb_controller_t dev,
     {
       grub_ohci_td_t td_prev_virt
 	= grub_ohci_td_phys2virt (o, cdata->td_current_virt->prev_td_phys);
-      
+
       if (cdata->td_current_virt == (grub_ohci_td_t) td_prev_virt->link_td)
         td_prev_virt->link_td = 0;
 
@@ -978,7 +978,7 @@ parse_halt (grub_usb_controller_t dev,
     }
   else
     transfer->last_trans = -1;
-  
+
   /* Evaluation of error code */
   grub_dprintf ("ohci", "OHCI tderr_phys=0x%02x, errcode=0x%02x\n",
 		cdata->tderr_phys, errcode);
@@ -1089,7 +1089,7 @@ parse_success (grub_usb_controller_t dev,
 
   /* Prepare pointer to last processed TD */
   tderr_virt = grub_ohci_td_phys2virt (o, cdata->tderr_phys);
-  
+
   /* Set index of last processed TD */
   if (tderr_virt)
     transfer->last_trans = tderr_virt->tr_index;
@@ -1207,7 +1207,7 @@ grub_ohci_cancel_transfer (grub_usb_controller_t dev,
   cdata->tderr_phys
     = grub_ohci_td_phys2virt (o, grub_le_to_cpu32 (cdata->ed_virt->td_head)
                               & ~0xf)->prev_td_phys;
-    
+
   tderr_virt = grub_ohci_td_phys2virt (o,cdata-> tderr_phys);
 
   grub_dprintf ("ohci", "Cancel: tderr_phys=0x%x, tderr_virt=%p\n",
@@ -1249,7 +1249,7 @@ grub_ohci_portstatus (grub_usb_controller_t dev,
          grub_ohci_readreg32 (o, GRUB_OHCI_REG_RHUBPORT + port));
        return GRUB_USB_ERR_NONE;
      }
-     
+
    /* OHCI does one reset signal 10ms long but USB spec.
     * requests 50ms for root hub (no need to be continuous).
     * So, we do reset 5 times... */
@@ -1276,7 +1276,7 @@ grub_ohci_portstatus (grub_usb_controller_t dev,
    grub_ohci_writereg32 (o, GRUB_OHCI_REG_RHUBPORT + port,
                          GRUB_OHCI_SET_PORT_ENABLE);
    grub_ohci_readreg32 (o, GRUB_OHCI_REG_RHUBPORT + port);
-   
+
    /* Wait for signal enabled */
    endtime = grub_get_time_ms () + 1000;
    while (! (grub_ohci_readreg32 (o, GRUB_OHCI_REG_RHUBPORT + port)
@@ -1290,10 +1290,10 @@ grub_ohci_portstatus (grub_usb_controller_t dev,
 
    /* "Reset recovery time" (USB spec.) */
    grub_millisleep (10);
-   
+
    grub_dprintf ("ohci", "end of portstatus=0x%02x\n",
 		 grub_ohci_readreg32 (o, GRUB_OHCI_REG_RHUBPORT + port));
- 
+
    return GRUB_USB_ERR_NONE;
 }
 
diff --git a/grub-core/bus/usb/serial/common.c b/grub-core/bus/usb/serial/common.c
index 8e94c7dc0..e9c995a0a 100644
--- a/grub-core/bus/usb/serial/common.c
+++ b/grub-core/bus/usb/serial/common.c
@@ -93,7 +93,7 @@ grub_usbserial_attach (grub_usb_device_t usbdev, int configno, int interfno,
   /* Configure device */
   if (port->out_endp && port->in_endp)
     err = grub_usb_set_configuration (usbdev, configno + 1);
-  
+
   if (!port->out_endp || !port->in_endp || err)
     {
       grub_free (port->name);
diff --git a/grub-core/bus/usb/serial/ftdi.c b/grub-core/bus/usb/serial/ftdi.c
index 1a99cba17..3c1388ed2 100644
--- a/grub-core/bus/usb/serial/ftdi.c
+++ b/grub-core/bus/usb/serial/ftdi.c
@@ -174,7 +174,7 @@ static struct grub_serial_driver grub_ftdi_driver =
     .fini = grub_usbserial_fini
   };
 
-static const struct 
+static const struct
 {
   grub_uint16_t vendor, product;
 } products[] =
diff --git a/grub-core/bus/usb/serial/pl2303.c b/grub-core/bus/usb/serial/pl2303.c
index d1945a2cb..8576c4611 100644
--- a/grub-core/bus/usb/serial/pl2303.c
+++ b/grub-core/bus/usb/serial/pl2303.c
@@ -187,7 +187,7 @@ static struct grub_serial_driver grub_pl2303_driver =
     .fini = grub_usbserial_fini
   };
 
-static const struct 
+static const struct
 {
   grub_uint16_t vendor, product;
 } products[] =
diff --git a/grub-core/bus/usb/uhci.c b/grub-core/bus/usb/uhci.c
index 7c5811fd6..0fdea4c1e 100644
--- a/grub-core/bus/usb/uhci.c
+++ b/grub-core/bus/usb/uhci.c
@@ -244,10 +244,10 @@ grub_uhci_pci_iter (grub_pci_device_t dev,
   u->iobase = (base & GRUB_UHCI_IOMASK) + GRUB_MACHINE_PCI_IO_BASE;
 
   /* Reset PIRQ and SMI */
-  addr = grub_pci_make_address (dev, GRUB_UHCI_REG_USBLEGSUP);       
+  addr = grub_pci_make_address (dev, GRUB_UHCI_REG_USBLEGSUP);
   grub_pci_write_word(addr, GRUB_UHCI_RESET_LEGSUP_SMI);
   /* Reset the HC */
-  grub_uhci_writereg16(u, GRUB_UHCI_REG_USBCMD, GRUB_UHCI_CMD_HCRESET); 
+  grub_uhci_writereg16(u, GRUB_UHCI_REG_USBCMD, GRUB_UHCI_CMD_HCRESET);
   grub_millisleep(5);
   /* Disable interrupts and commands (just to be safe) */
   grub_uhci_writereg16(u, GRUB_UHCI_REG_USBINTR, 0);
@@ -399,7 +399,7 @@ grub_free_queue (struct grub_uhci *u, grub_uhci_qh_t qh, grub_uhci_td_t td,
   u->qh_busy[qh - u->qh_virt] = 0;
 
   *actual = 0;
-  
+
   /* Free the TDs in this queue and set last_trans.  */
   for (i=0; td; i++)
     {
@@ -411,7 +411,7 @@ grub_free_queue (struct grub_uhci *u, grub_uhci_qh_t qh, grub_uhci_td_t td,
         transfer->last_trans = i;
 
       *actual += (td->ctrl_status + 1) & 0x7ff;
-      
+
       /* Unlink the queue.  */
       tdprev = td;
       if (!td->linkptr2)
@@ -537,7 +537,7 @@ grub_uhci_setup_transfer (grub_usb_controller_t dev,
     }
 
   grub_dprintf ("uhci", "transfer, iobase:%08x\n", u->iobase);
-  
+
   for (i = 0; i < transfer->transcnt; i++)
     {
       grub_usb_transaction_t tr = &transfer->transactions[i];
@@ -604,7 +604,7 @@ grub_uhci_check_transfer (grub_usb_controller_t dev,
     errtd = grub_dma_phys2virt (cdata->qh->elinkptr & ~0x0f, u->qh_chunk);
   else
     errtd = 0;
-  
+
   if (errtd)
     {
       grub_dprintf ("uhci", ">t status=0x%02x data=0x%02x td=%p, %x\n",
@@ -632,27 +632,27 @@ grub_uhci_check_transfer (grub_usb_controller_t dev,
       /* Check if the endpoint is stalled.  */
       if (errtd->ctrl_status & (1 << 22))
 	err = GRUB_USB_ERR_STALL;
-      
+
       /* Check if an error related to the data buffer occurred.  */
       else if (errtd->ctrl_status & (1 << 21))
 	err = GRUB_USB_ERR_DATA;
-      
+
       /* Check if a babble error occurred.  */
       else if (errtd->ctrl_status & (1 << 20))
 	err = GRUB_USB_ERR_BABBLE;
-      
+
       /* Check if a NAK occurred.  */
       else if (errtd->ctrl_status & (1 << 19))
 	err = GRUB_USB_ERR_NAK;
-      
+
       /* Check if a timeout occurred.  */
       else if (errtd->ctrl_status & (1 << 18))
 	err = GRUB_USB_ERR_TIMEOUT;
-      
+
       /* Check if a bitstuff error occurred.  */
       else if (errtd->ctrl_status & (1 << 17))
 	err = GRUB_USB_ERR_BITSTUFF;
-      
+
       if (err)
 	{
 	  grub_dprintf ("uhci", "transaction failed\n");
@@ -719,7 +719,7 @@ grub_uhci_portstatus (grub_usb_controller_t dev,
   grub_uint64_t endtime;
 
   grub_dprintf ("uhci", "portstatus, iobase:%08x\n", u->iobase);
-  
+
   grub_dprintf ("uhci", "enable=%d port=%d\n", enable, port);
 
   if (port == 0)
@@ -746,7 +746,7 @@ grub_uhci_portstatus (grub_usb_controller_t dev,
       grub_dprintf ("uhci", ">3detect=0x%02x\n", status);
       return GRUB_USB_ERR_NONE;
     }
-    
+
   /* Reset the port.  */
   status = grub_uhci_readreg16 (u, reg) & ~GRUB_UHCI_PORTSC_RWC;
   grub_uhci_writereg16 (u, reg, status | (1 << 9));
@@ -796,7 +796,7 @@ grub_uhci_detect_dev (grub_usb_controller_t dev, int port, int *changed)
   unsigned int status;
 
   grub_dprintf ("uhci", "detect_dev, iobase:%08x\n", u->iobase);
-  
+
   if (port == 0)
     reg = GRUB_UHCI_REG_PORTSC1;
   else if (port == 1)
@@ -818,7 +818,7 @@ grub_uhci_detect_dev (grub_usb_controller_t dev, int port, int *changed)
     }
   else
     *changed = 0;
-    
+
   if (! (status & GRUB_UHCI_DETECT_HAVE_DEVICE))
     return GRUB_USB_SPEED_NONE;
   else if (status & GRUB_UHCI_DETECT_LOW_SPEED)
diff --git a/grub-core/bus/usb/usb.c b/grub-core/bus/usb/usb.c
index 7cb3cc230..7bd49d201 100644
--- a/grub-core/bus/usb/usb.c
+++ b/grub-core/bus/usb/usb.c
@@ -144,7 +144,7 @@ grub_usb_device_initialize (grub_usb_device_t dev)
     {
       err = GRUB_USB_ERR_BADDEVICE;
       goto fail;
-    }    
+    }
 
   for (i = 0; i < descdev->configcnt; i++)
     {
@@ -235,7 +235,7 @@ grub_usb_device_initialize (grub_usb_device_t dev)
 void grub_usb_device_attach (grub_usb_device_t dev)
 {
   int i;
-  
+
   /* XXX: Just check configuration 0 for now.  */
   for (i = 0; i < dev->config[0].descconf->numif; i++)
     {
@@ -331,7 +331,7 @@ grub_usb_register_attach_hook_class (struct grub_usb_attach_desc *desc)
 void
 grub_usb_unregister_attach_hook_class (struct grub_usb_attach_desc *desc)
 {
-  grub_list_remove (GRUB_AS_LIST (desc));  
+  grub_list_remove (GRUB_AS_LIST (desc));
 }
 
 
diff --git a/grub-core/bus/usb/usbhub.c b/grub-core/bus/usb/usbhub.c
index 85ccf3a4b..f5608e330 100644
--- a/grub-core/bus/usb/usbhub.c
+++ b/grub-core/bus/usb/usbhub.c
@@ -115,11 +115,11 @@ grub_usb_hub_add_dev (grub_usb_controller_t controller,
   grub_millisleep (2);
 
   grub_boot_time ("Probing USB device driver");
-  
+
   grub_usb_device_attach (dev);
 
   grub_boot_time ("Attached USB device");
-  
+
   return dev;
 }
 
@@ -130,7 +130,7 @@ grub_usb_add_hub (grub_usb_device_t dev)
   struct grub_usb_usb_hubdesc hubdesc;
   grub_usb_err_t err;
   int i;
-  
+
   err = grub_usb_control_msg (dev, (GRUB_USB_REQTYPE_IN
 	  		            | GRUB_USB_REQTYPE_CLASS
 			            | GRUB_USB_REQTYPE_TARGET_DEV),
@@ -328,7 +328,7 @@ grub_usb_controller_dev_register (grub_usb_controller_dev_t usb)
 
 		speed = hub->controller->dev->detect_dev (hub->controller, portno,
 							  &changed);
-      
+
 		if (hub->ports[portno].state == PORT_STATE_NORMAL
 		    && speed != GRUB_USB_SPEED_NONE)
 		  {
@@ -422,7 +422,7 @@ wait_power_nonroot_hub (grub_usb_device_t dev)
   grub_usb_err_t err;
   int continue_waiting = 0;
   unsigned i;
-  
+
   for (i = 1; i <= dev->nports; i++)
     if (dev->ports[i - 1].state == PORT_STATE_WAITING_FOR_STABLE_POWER)
       {
@@ -564,7 +564,7 @@ poll_nonroot_hub (grub_usb_device_t dev)
 
 	  detach_device (dev->children[i - 1]);
 	  dev->children[i - 1] = NULL;
-      	    
+
 	  /* Connected and status of connection changed ? */
 	  if (status & GRUB_USB_HUB_STATUS_PORT_CONNECTED)
 	    {
@@ -642,7 +642,7 @@ poll_nonroot_hub (grub_usb_device_t dev)
 		    split_hubport = dev->split_hubport;
 		    split_hubaddr = dev->split_hubaddr;
 		  }
-		
+
 	      /* Add the device and assign a device address to it.  */
 	      next_dev = grub_usb_hub_add_dev (&dev->controller, speed,
 					       split_hubport, split_hubaddr);
@@ -707,12 +707,12 @@ grub_usb_poll_devices (int wait_for_completion)
   while (1)
     {
       rescan = 0;
-      
+
       /* We should check changes of non-root hubs too. */
       for (i = 0; i < GRUB_USBHUB_MAX_DEVICES; i++)
 	{
 	  grub_usb_device_t dev = grub_usb_devs[i];
-	  
+
 	  if (dev && dev->descdev.class == 0x09)
 	    poll_nonroot_hub (dev);
 	}
@@ -723,7 +723,7 @@ grub_usb_poll_devices (int wait_for_completion)
 	  for (i = 0; i < GRUB_USBHUB_MAX_DEVICES; i++)
 	    {
 	      grub_usb_device_t dev = grub_usb_devs[i];
-	    
+
 	      if (dev && dev->descdev.class == 0x09)
 		continue_waiting = continue_waiting || wait_power_nonroot_hub (dev);
 	    }
diff --git a/grub-core/bus/usb/usbtrans.c b/grub-core/bus/usb/usbtrans.c
index 85f081fff..c5680b33a 100644
--- a/grub-core/bus/usb/usbtrans.c
+++ b/grub-core/bus/usb/usbtrans.c
@@ -40,7 +40,7 @@ grub_usb_bulk_maxpacket (grub_usb_device_t dev,
 
 
 static grub_usb_err_t
-grub_usb_execute_and_wait_transfer (grub_usb_device_t dev, 
+grub_usb_execute_and_wait_transfer (grub_usb_device_t dev,
 				    grub_usb_transfer_t transfer,
 				    int timeout, grub_size_t *actual)
 {
@@ -205,7 +205,7 @@ grub_usb_control_msg (grub_usb_device_t dev,
   grub_dprintf ("usb", "control: err=%d\n", err);
 
   grub_free (transfer->transactions);
-  
+
   grub_free (transfer);
   grub_dma_free (setupdata_chunk);
 
-- 
2.36.1

