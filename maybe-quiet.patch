diff -Naur grub-2.04/config.h.in grub-2.04.tpg/config.h.in
--- grub-2.04/config.h.in	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/config.h.in	2020-03-15 21:00:34.804083707 +0000
@@ -12,6 +12,8 @@
 /* Define to 1 to enable disk cache statistics.  */
 #define DISK_CACHE_STATS @DISK_CACHE_STATS@
 #define BOOT_TIME_STATS @BOOT_TIME_STATS@
+/* Define to 1 to make GRUB quieter at boot time.  */
+#define QUIET_BOOT @QUIET_BOOT@
 
 /* We don't need those.  */
 #define MINILZO_CFG_SKIP_LZO_PTR 1
diff -Naur grub-2.04/configure.ac grub-2.04.tpg/configure.ac
--- grub-2.04/configure.ac	2020-03-15 20:57:21.896497368 +0000
+++ grub-2.04.tpg/configure.ac	2020-03-15 21:02:50.812518160 +0000
@@ -1846,6 +1846,17 @@
 AC_SUBST([LIBZFS])
 AC_SUBST([LIBNVPAIR])
 
+AC_ARG_ENABLE([quiet-boot],
+              [AS_HELP_STRING([--enable-quiet-boot],
+                              [emit fewer messages at boot time (default=no)])],
+              [], [enable_quiet_boot=no])
+if test x"$enable_quiet_boot" = xyes ; then
+  QUIET_BOOT=1
+else
+  QUIET_BOOT=0
+fi
+AC_SUBST([QUIET_BOOT])
+
 LIBS=""
 
 AC_SUBST([FONT_SOURCE])
@@ -2102,5 +2113,10 @@
 else
 echo "With liblzma from $LIBLZMA (support for XZ-compressed mips images)"
 fi
+if [ x"$enable_quiet_boot" = xyes ]; then
+echo With quiet boot: Yes
+else
+echo With quiet boot: No
+fi
 echo "*******************************************************"
 ]
diff -Naur grub-2.04/grub-core/boot/i386/pc/boot.S grub-2.04.tpg/grub-core/boot/i386/pc/boot.S
--- grub-2.04/grub-core/boot/i386/pc/boot.S	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/grub-core/boot/i386/pc/boot.S	2020-03-15 21:00:34.804083707 +0000
@@ -19,6 +19,9 @@
 
 #include <grub/symbol.h>
 #include <grub/machine/boot.h>
+#if QUIET_BOOT && !defined(HYBRID_BOOT)
+#include <grub/machine/memory.h>
+#endif
 
 /*
  *  defines for the code go here
@@ -249,9 +252,17 @@
 	/* save drive reference first thing! */
 	pushw	%dx
 
+#if QUIET_BOOT && !defined(HYBRID_BOOT)
+	/* is either shift key held down? */
+	movw	$(GRUB_MEMORY_MACHINE_BIOS_DATA_AREA_ADDR + 0x17), %bx
+	testb	$3, (%bx)
+	jz	2f
+#endif
+
 	/* print a notification message on the screen */
 	MSG(notification_string)
 
+2:
 	/* set %si to the disk address packet */
 	movw	$disk_address_packet, %si
 
diff -Naur grub-2.04/grub-core/boot/i386/pc/diskboot.S grub-2.04.tpg/grub-core/boot/i386/pc/diskboot.S
--- grub-2.04/grub-core/boot/i386/pc/diskboot.S	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/grub-core/boot/i386/pc/diskboot.S	2020-03-15 21:00:34.804083707 +0000
@@ -18,6 +18,9 @@
 
 #include <grub/symbol.h>
 #include <grub/machine/boot.h>
+#if QUIET_BOOT
+#include <grub/machine/memory.h>
+#endif
 
 /*
  *  defines for the code go here
@@ -25,6 +28,12 @@
 
 #define MSG(x)	movw $x, %si; call LOCAL(message)
 
+#if QUIET_BOOT
+#define SILENT(x)	call LOCAL(check_silent); jz LOCAL(x)
+#else
+#define SILENT(x)
+#endif
+
 	.file	"diskboot.S"
 
 	.text
@@ -50,11 +59,14 @@
 	/* save drive reference first thing! */
 	pushw	%dx
 
+	SILENT(after_notification_string)
+
 	/* print a notification message on the screen */
 	pushw	%si
 	MSG(notification_string)
 	popw	%si
 
+LOCAL(after_notification_string):
 	/* this sets up for the first run through "bootloop" */
 	movw	$LOCAL(firstlist), %di
 
@@ -279,7 +291,10 @@
 	/* restore addressing regs and print a dot with correct DS
 	   (MSG modifies SI, which is saved, and unused AX and BX) */
 	popw	%ds
+	SILENT(after_notification_step)
 	MSG(notification_step)
+
+LOCAL(after_notification_step):
 	popa
 
 	/* check if finished with this dataset */
@@ -295,8 +310,11 @@
 /* END OF MAIN LOOP */
 
 LOCAL(bootit):
+	SILENT(after_notification_done)
 	/* print a newline */
 	MSG(notification_done)
+
+LOCAL(after_notification_done):
 	popw	%dx	/* this makes sure %dl is our "boot" drive */
 	ljmp	$0, $(GRUB_BOOT_MACHINE_KERNEL_ADDR + 0x200)
 
@@ -320,6 +338,14 @@
 /* go here when you need to stop the machine hard after an error condition */
 LOCAL(stop):	jmp	LOCAL(stop)
 
+#if QUIET_BOOT
+LOCAL(check_silent):
+	/* is either shift key held down? */
+	movw	$(GRUB_MEMORY_MACHINE_BIOS_DATA_AREA_ADDR + 0x17), %bx
+	testb	$3, (%bx)
+	ret
+#endif
+
 notification_string:	.asciz "loading"
 
 notification_step:	.asciz "."
diff -Naur grub-2.04/grub-core/kern/main.c grub-2.04.tpg/grub-core/kern/main.c
--- grub-2.04/grub-core/kern/main.c	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/grub-core/kern/main.c	2020-03-15 21:00:34.804083707 +0000
@@ -264,15 +264,25 @@
 void __attribute__ ((noreturn))
 grub_main (void)
 {
+#if QUIET_BOOT
+  struct grub_term_output *term;
+#endif
+
   /* First of all, initialize the machine.  */
   grub_machine_init ();
 
   grub_boot_time ("After machine init.");
 
+#if QUIET_BOOT
+  /* Disable the cursor until we need it.  */
+  FOR_ACTIVE_TERM_OUTPUTS(term)
+    grub_term_setcursor (term, 0);
+#else
   /* Hello.  */
   grub_setcolorstate (GRUB_TERM_COLOR_HIGHLIGHT);
   grub_printf ("Welcome to GRUB!\n\n");
   grub_setcolorstate (GRUB_TERM_COLOR_STANDARD);
+#endif
 
   grub_load_config ();
 
@@ -308,5 +318,12 @@
   grub_boot_time ("After execution of embedded config. Attempt to go to normal mode");
 
   grub_load_normal_mode ();
+
+#if QUIET_BOOT
+  /* If we have to enter rescue mode, enable the cursor again.  */
+  FOR_ACTIVE_TERM_OUTPUTS(term)
+    grub_term_setcursor (term, 1);
+#endif
+
   grub_rescue_run ();
 }
diff -Naur grub-2.04/grub-core/kern/rescue_reader.c grub-2.04.tpg/grub-core/kern/rescue_reader.c
--- grub-2.04/grub-core/kern/rescue_reader.c	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/grub-core/kern/rescue_reader.c	2020-03-15 21:00:34.804083707 +0000
@@ -78,7 +78,9 @@
 void __attribute__ ((noreturn))
 grub_rescue_run (void)
 {
+#if QUIET_BOOT
   grub_printf ("Entering rescue mode...\n");
+#endif
 
   while (1)
     {
diff -Naur grub-2.04/grub-core/normal/main.c grub-2.04.tpg/grub-core/normal/main.c
--- grub-2.04/grub-core/normal/main.c	2018-11-24 17:13:02.000000000 +0000
+++ grub-2.04.tpg/grub-core/normal/main.c	2020-03-15 21:00:34.804083707 +0000
@@ -389,6 +389,15 @@
 grub_normal_read_line_real (char **line, int cont, int nested)
 {
   const char *prompt;
+#if QUIET_BOOT
+  static int displayed_intro;
+
+  if (! displayed_intro)
+    {
+      grub_normal_reader_init (nested);
+      displayed_intro = 1;
+    }
+#endif
 
   if (cont)
     /* TRANSLATORS: it's command line prompt.  */
@@ -441,7 +450,9 @@
       return;
     }
 
+#if !QUIET_BOOT
   grub_normal_reader_init (nested);
+#endif
 
   while (1)
     {
diff -Naur grub-2.04/grub-core/normal/menu.c grub-2.04.tpg/grub-core/normal/menu.c
--- grub-2.04/grub-core/normal/menu.c	2019-04-23 08:54:47.000000000 +0000
+++ grub-2.04.tpg/grub-core/normal/menu.c	2020-03-15 21:00:34.805083710 +0000
@@ -808,12 +808,18 @@
 
 /* Callback invoked immediately before a menu entry is executed.  */
 static void
-notify_booting (grub_menu_entry_t entry,
+notify_booting (grub_menu_entry_t entry
+#if QUIET_BOOT
+		__attribute__((unused))
+#endif
+		,
 		void *userdata __attribute__((unused)))
 {
+#if !QUIET_BOOT
   grub_printf ("  ");
   grub_printf_ (N_("Booting `%s'"), entry->title);
   grub_printf ("\n\n");
+#endif
 }
 
 /* Callback invoked when a default menu entry executed because of a timeout
@@ -861,6 +867,9 @@
       int boot_entry;
       grub_menu_entry_t e;
       int auto_boot;
+#if QUIET_BOOT
+      int initial_timeout = grub_menu_get_timeout ();
+#endif
 
       boot_entry = run_menu (menu, nested, &auto_boot);
       if (boot_entry < 0)
@@ -870,7 +879,11 @@
       if (! e)
 	continue; /* Menu is empty.  */
 
-      grub_cls ();
+#if QUIET_BOOT
+      /* Only clear the screen if we drew the menu in the first place.  */
+      if (initial_timeout != 0)
+#endif
+	grub_cls ();
 
       if (auto_boot)
 	grub_menu_execute_with_fallback (menu, e, autobooted,
diff -Naur grub-2.04/util/grub.d/10_linux.in grub-2.04.tpg/util/grub.d/10_linux.in
--- grub-2.04/util/grub.d/10_linux.in	2020-03-15 20:57:21.899497377 +0000
+++ grub-2.04.tpg/util/grub.d/10_linux.in	2020-03-15 21:06:12.735185971 +0000
@@ -20,6 +20,7 @@
 prefix="@prefix@"
 exec_prefix="@exec_prefix@"
 datarootdir="@datarootdir@"
+quiet_boot="@QUIET_BOOT@"
 
 . "$pkgdatadir/grub-mkconfig_lib"
 
@@ -162,20 +163,26 @@
     fi
     printf '%s\n' "${prepare_boot_cache}" | sed "s/^/$submenu_indentation/"
   fi
-  message="$(gettext_printf "Loading Linux %s ..." ${version})"
-  sed "s/^/$submenu_indentation/" << EOF
+  if [ x"$quiet_boot" = x0 ] || [ x"$type" != xsimple ]; then
+    message="$(gettext_printf "Loading Linux %s ..." ${version})"
+    sed "s/^/$submenu_indentation/" << EOF
 	echo	'$(echo "$message" | grub_quote)'
 	linux	${rel_dirname}/${basename} root=${linux_root_device_thisversion} ro ${args}
 EOF
+  fi
   if test -n "${initrd}" ; then
     # TRANSLATORS: ramdisk isn't identifier. Should be translated.
-    message="$(gettext_printf "Loading initial ramdisk ...")"
+    if [ x"$quiet_boot" = x0 ] || [ x"$type" != xsimple ]; then
+      message="$(gettext_printf "Loading initial ramdisk ...")"
+      sed "s/^/$submenu_indentation/" << EOF
+       echo    '$(echo "$message" | grub_quote)'
+EOF
+    fi
     initrd_path=
     for i in ${initrd}; do
       initrd_path="${initrd_path} ${rel_dirname}/${i}"
     done
     sed "s/^/$submenu_indentation/" << EOF
-	echo	'$(echo "$message" | grub_quote)'
 	initrd	$(echo $initrd_path)
 EOF
   fi
