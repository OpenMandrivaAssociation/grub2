From 6a4d9e859e206d2057ee926d969f4da7afb2edc7 Mon Sep 17 00:00:00 2001
From: Elyes Haouas <ehaouas@noos.fr>
Date: Fri, 4 Mar 2022 07:42:05 +0100
Subject: [PATCH 133/261] loader: Remove trailing whitespaces

Signed-off-by: Elyes Haouas <ehaouas@noos.fr>
Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
---
 grub-core/loader/arm/linux.c                 |  2 +-
 grub-core/loader/efi/appleloader.c           |  2 +-
 grub-core/loader/i386/bsd.c                  | 26 ++++++++--------
 grub-core/loader/i386/bsdXX.c                | 10 +++---
 grub-core/loader/i386/coreboot/chainloader.c |  2 +-
 grub-core/loader/i386/linux.c                |  8 ++---
 grub-core/loader/i386/multiboot_mbi.c        | 32 ++++++++++----------
 grub-core/loader/i386/pc/chainloader.c       |  6 ++--
 grub-core/loader/i386/pc/freedos.c           |  4 +--
 grub-core/loader/i386/pc/linux.c             |  2 +-
 grub-core/loader/i386/pc/ntldr.c             |  4 +--
 grub-core/loader/i386/pc/plan9.c             | 10 +++---
 grub-core/loader/i386/pc/pxechainloader.c    |  4 +--
 grub-core/loader/i386/pc/truecrypt.c         |  4 +--
 grub-core/loader/i386/xnu.c                  |  6 ++--
 grub-core/loader/ia64/efi/linux.c            | 28 ++++++++---------
 grub-core/loader/linux.c                     |  2 +-
 grub-core/loader/lzss.c                      |  2 +-
 grub-core/loader/mips/linux.c                |  8 ++---
 grub-core/loader/multiboot.c                 |  2 +-
 grub-core/loader/multiboot_elfxx.c           |  8 ++---
 grub-core/loader/multiboot_mbi2.c            | 30 +++++++++---------
 grub-core/loader/xnu.c                       | 10 +++---
 23 files changed, 106 insertions(+), 106 deletions(-)

diff --git a/grub-core/loader/arm/linux.c b/grub-core/loader/arm/linux.c
index ed23dc71e..30b366601 100644
--- a/grub-core/loader/arm/linux.c
+++ b/grub-core/loader/arm/linux.c
@@ -452,7 +452,7 @@ load_dtb (grub_file_t dtb, int size)
 
   grub_fdt_set_totalsize (new_fdt, size);
   current_fdt = new_fdt;
-  /* 
+  /*
    * We've successfully loaded an FDT, so any machine type passed
    * from firmware is now obsolete.
    */
diff --git a/grub-core/loader/efi/appleloader.c b/grub-core/loader/efi/appleloader.c
index 74888c463..fc89e23bd 100644
--- a/grub-core/loader/efi/appleloader.c
+++ b/grub-core/loader/efi/appleloader.c
@@ -126,7 +126,7 @@ static struct piwg_full_device_path devpath_6 = MAKE_PIWG_PATH (0xffcc4000,
 static struct piwg_full_device_path devpath_7 = MAKE_PIWG_PATH (0xff981000,
 								0xffc8ffff);
 
-/* mid-2012 MBP retina (MacBookPro10,1) */ 
+/* mid-2012 MBP retina (MacBookPro10,1) */
 static struct piwg_full_device_path devpath_8 = MAKE_PIWG_PATH (0xff990000,
 								0xffb2ffff);
 
diff --git a/grub-core/loader/i386/bsd.c b/grub-core/loader/i386/bsd.c
index 5f3290ce1..6c324ca30 100644
--- a/grub-core/loader/i386/bsd.c
+++ b/grub-core/loader/i386/bsd.c
@@ -135,7 +135,7 @@ static const struct grub_arg_option openbsd_opts[] =
     {"single", 's', 0, N_("Boot into single mode."), 0, 0},
     {"kdb", 'd', 0, N_("Enter in KDB on boot."), 0, 0},
     {"root", 'r', 0, N_("Set root device."), "wdXY", ARG_TYPE_STRING},
-    {"serial", 'h', GRUB_ARG_OPTION_OPTIONAL, 
+    {"serial", 'h', GRUB_ARG_OPTION_OPTIONAL,
      N_("Use serial console."),
      /* TRANSLATORS: "com" is static and not to be translated. It refers to
 	serial ports e.g. com1.
@@ -168,7 +168,7 @@ static const struct grub_arg_option netbsd_opts[] =
     {"debug", 'x', 0, N_("Boot with debug messages."), 0, 0},
     {"silent", 'z', 0, N_("Suppress normal output (warnings remain)."), 0, 0},
     {"root", 'r', 0, N_("Set root device."), N_("DEVICE"), ARG_TYPE_STRING},
-    {"serial", 'h', GRUB_ARG_OPTION_OPTIONAL, 
+    {"serial", 'h', GRUB_ARG_OPTION_OPTIONAL,
      N_("Use serial console."),
      /* TRANSLATORS: "com" is static and not to be translated. It refers to
 	serial ports e.g. com1.
@@ -231,7 +231,7 @@ grub_bsd_add_meta_ptr (grub_uint32_t type, void **ptr, grub_uint32_t len)
   newtag->next = NULL;
   *ptr = newtag->data;
 
-  if (kernel_type == KERNEL_TYPE_FREEBSD 
+  if (kernel_type == KERNEL_TYPE_FREEBSD
       && type == (FREEBSD_MODINFO_METADATA | FREEBSD_MODINFOMD_SMAP))
     {
       struct bsd_tag *p;
@@ -435,7 +435,7 @@ grub_freebsd_add_meta_module (const char *filename, const char *type,
     {
       grub_uint64_t addr64 = addr, size64 = size;
       if (grub_bsd_add_meta (FREEBSD_MODINFO_TYPE, type, grub_strlen (type) + 1)
-	  || grub_bsd_add_meta (FREEBSD_MODINFO_ADDR, &addr64, sizeof (addr64)) 
+	  || grub_bsd_add_meta (FREEBSD_MODINFO_ADDR, &addr64, sizeof (addr64))
 	  || grub_bsd_add_meta (FREEBSD_MODINFO_SIZE, &size64, sizeof (size64)))
 	return grub_errno;
     }
@@ -633,7 +633,7 @@ grub_freebsd_boot (void)
       err = grub_bsd_add_meta (FREEBSD_MODINFO_END, 0, 0);
       if (err)
 	return err;
-      
+
       tag_buf_len = 0;
       for (tag = tags; tag; tag = tag->next)
 	tag_buf_len = ALIGN_VAR (tag_buf_len
@@ -678,7 +678,7 @@ grub_freebsd_boot (void)
     {
       grub_uint8_t *p_tag = p;
       struct bsd_tag *tag;
-      
+
       for (tag = tags; tag; tag = tag->next)
 	{
 	  struct freebsd_tag_header *head
@@ -842,7 +842,7 @@ grub_openbsd_boot (void)
     if (regs.edx == 0x20494350)
       {
 	struct grub_openbsd_bootarg_pcibios pcibios;
-	
+
 	pcibios.characteristics = regs.eax & 0xff;
 	pcibios.revision = regs.ebx & 0xffff;
 	pcibios.pm_entry = regs.edi;
@@ -1500,7 +1500,7 @@ grub_bsd_load (int argc, char *argv[])
 fail:
 
   if (grub_errno != GRUB_ERR_NONE)
-    grub_dl_unref (my_mod);	
+    grub_dl_unref (my_mod);
 
   return grub_errno;
 }
@@ -1658,7 +1658,7 @@ grub_cmd_openbsd (grub_extcmd_context_t ctxt, int argc, char *argv[])
 			       "only com0-com3 are supported");
 	  if (*ptr == ',')
 	    {
-	      ptr++; 
+	      ptr++;
 	      speed = grub_strtoul (ptr, &ptr, 0);
 	      if (grub_errno)
 		return grub_errno;
@@ -1668,7 +1668,7 @@ grub_cmd_openbsd (grub_extcmd_context_t ctxt, int argc, char *argv[])
       serial.device = (GRUB_OPENBSD_COM_MAJOR << 8) | port;
       serial.speed = speed;
       serial.addr = grub_ns8250_hw_get_port (port);
-	  
+
       grub_bsd_add_meta (OPENBSD_BOOTARG_CONSOLE, &serial, sizeof (serial));
       bootflags |= OPENBSD_RB_SERCONS;
     }
@@ -1755,7 +1755,7 @@ grub_cmd_netbsd (grub_extcmd_context_t ctxt, int argc, char *argv[])
 	      if (grub_memcmp (ptr, "com", sizeof ("com") - 1) == 0)
 		{
 		  ptr += sizeof ("com") - 1;
-		  serial.addr 
+		  serial.addr
 		    = grub_ns8250_hw_get_port (grub_strtoul (ptr, &ptr, 0));
 		}
 	      else
@@ -1925,7 +1925,7 @@ grub_cmd_freebsd_module (grub_command_t cmd __attribute__ ((unused)),
 
   {
     grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_addr (relocator, &ch, kern_end, 
+    err = grub_relocator_alloc_chunk_addr (relocator, &ch, kern_end,
 					   file->size);
     if (err)
       goto fail;
@@ -1976,7 +1976,7 @@ grub_netbsd_module_load (char *filename, grub_uint32_t type)
 
   {
     grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_addr (relocator, &ch, kern_end, 
+    err = grub_relocator_alloc_chunk_addr (relocator, &ch, kern_end,
 					   file->size);
     if (err)
       goto fail;
diff --git a/grub-core/loader/i386/bsdXX.c b/grub-core/loader/i386/bsdXX.c
index a8d8bf7da..e4f4aa365 100644
--- a/grub-core/loader/i386/bsdXX.c
+++ b/grub-core/loader/i386/bsdXX.c
@@ -151,7 +151,7 @@ SUFFIX (grub_freebsd_load_elfmodule_obj) (struct grub_relocator *relocator,
 				      argc - 1, argv + 1, module,
 				      curload - module);
   if (! err)
-    err = grub_bsd_add_meta (FREEBSD_MODINFO_METADATA 
+    err = grub_bsd_add_meta (FREEBSD_MODINFO_METADATA
 			     | FREEBSD_MODINFOMD_ELFHDR,
 			     &e, sizeof (e));
   if (! err)
@@ -479,7 +479,7 @@ SUFFIX (grub_netbsd_load_elf_meta) (struct grub_relocator *relocator,
   symtab.esyms = symtarget + chunk_size;
 
   curload = sym_chunk;
-  
+
   e2 = (Elf_Ehdr *) curload;
   grub_memcpy (curload, &e, sizeof (e));
   e2->e_phoff = 0;
@@ -539,7 +539,7 @@ SUFFIX (grub_netbsd_load_elf_meta) (struct grub_relocator *relocator,
       goto out;
     }
 
-  err = grub_bsd_add_meta (NETBSD_BTINFO_SYMTAB, 
+  err = grub_bsd_add_meta (NETBSD_BTINFO_SYMTAB,
 			   &symtab,
 			   sizeof (symtab));
 out:
@@ -566,7 +566,7 @@ SUFFIX(grub_openbsd_find_ramdisk) (grub_file_t file,
     Elf_Ehdr e;
     Elf_Shdr *s;
     char *shdr = NULL;
-    
+
     err = read_headers (file, filename, &e, &shdr);
     if (err)
       {
@@ -588,7 +588,7 @@ SUFFIX(grub_openbsd_find_ramdisk) (grub_file_t file,
     symsize = s->sh_size;
     symentsize = s->sh_entsize;
     symoff = s->sh_offset;
-    
+
     s = (Elf_Shdr *) (shdr + e.e_shentsize * s->sh_link);
     stroff = s->sh_offset;
     strsize = s->sh_size;
diff --git a/grub-core/loader/i386/coreboot/chainloader.c b/grub-core/loader/i386/coreboot/chainloader.c
index 0a19ebb9c..4a5179806 100644
--- a/grub-core/loader/i386/coreboot/chainloader.c
+++ b/grub-core/loader/i386/coreboot/chainloader.c
@@ -461,7 +461,7 @@ grub_cmd_chain (grub_command_t cmd __attribute__ ((unused)),
 			   "payload is too short");
       return grub_errno;
     }
-      
+
   switch (head)
     {
     case ELFMAG0 | (ELFMAG1 << 8) | (ELFMAG2 << 16) | (ELFMAG3 << 24):
diff --git a/grub-core/loader/i386/linux.c b/grub-core/loader/i386/linux.c
index 9f74a96b1..c5984d4b2 100644
--- a/grub-core/loader/i386/linux.c
+++ b/grub-core/loader/i386/linux.c
@@ -286,7 +286,7 @@ grub_linux_setup_video (struct linux_kernel_params *params)
 	  params->lfb_size >>= 16;
 	  params->have_vga = GRUB_VIDEO_LINUX_TYPE_VESA;
 	  break;
-	
+
 	case GRUB_VIDEO_DRIVER_EFI_UGA:
 	case GRUB_VIDEO_DRIVER_EFI_GOP:
 	  params->have_vga = GRUB_VIDEO_LINUX_TYPE_EFIFB;
@@ -591,9 +591,9 @@ grub_linux_boot (void)
 					 &efi_desc_size, &efi_desc_version);
     if (err)
       return err;
-    
+
     /* Note that no boot services are available from here.  */
-    efi_mmap_target = ctx.real_mode_target 
+    efi_mmap_target = ctx.real_mode_target
       + ((grub_uint8_t *) efi_mmap_buf - (grub_uint8_t *) real_mode_mem);
     /* Pass EFI parameters.  */
     if (grub_le_to_cpu16 (ctx.params->version) >= 0x0208)
@@ -743,7 +743,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
       align = 0;
       relocatable = 0;
     }
-    
+
   if (grub_le_to_cpu16 (lh.version) >= 0x020a)
     {
       min_align = lh.min_alignment;
diff --git a/grub-core/loader/i386/multiboot_mbi.c b/grub-core/loader/i386/multiboot_mbi.c
index a67d9d0a8..ff1a846af 100644
--- a/grub-core/loader/i386/multiboot_mbi.c
+++ b/grub-core/loader/i386/multiboot_mbi.c
@@ -103,7 +103,7 @@ load_kernel (grub_file_t file, const char *filename,
       else
 	code_size = load_size;
 
-      err = grub_relocator_alloc_chunk_addr (grub_multiboot_relocator, 
+      err = grub_relocator_alloc_chunk_addr (grub_multiboot_relocator,
 					     &ch, header->load_addr,
 					     code_size);
       if (err)
@@ -200,7 +200,7 @@ grub_multiboot_load (grub_file_t file, const char *filename)
       switch (header->mode_type)
 	{
 	case 1:
-	  err = grub_multiboot_set_console (GRUB_MULTIBOOT_CONSOLE_EGA_TEXT, 
+	  err = grub_multiboot_set_console (GRUB_MULTIBOOT_CONSOLE_EGA_TEXT,
 					    GRUB_MULTIBOOT_CONSOLE_EGA_TEXT
 					    | GRUB_MULTIBOOT_CONSOLE_FRAMEBUFFER,
 					    0, 0, 0, 0);
@@ -213,14 +213,14 @@ grub_multiboot_load (grub_file_t file, const char *filename)
 					    header->depth, 0);
 	  break;
 	default:
-	  err = grub_error (GRUB_ERR_BAD_OS, 
+	  err = grub_error (GRUB_ERR_BAD_OS,
 			    "unsupported graphical mode type %d",
 			    header->mode_type);
 	  break;
 	}
     }
   else
-    err = grub_multiboot_set_console (GRUB_MULTIBOOT_CONSOLE_EGA_TEXT, 
+    err = grub_multiboot_set_console (GRUB_MULTIBOOT_CONSOLE_EGA_TEXT,
 				      GRUB_MULTIBOOT_CONSOLE_EGA_TEXT,
 				      0, 0, 0, 0);
   return err;
@@ -238,7 +238,7 @@ grub_multiboot_get_mbi_size (void)
 
   ret = sizeof (struct multiboot_info) + ALIGN_UP (cmdline_size, 4)
     + modcnt * sizeof (struct multiboot_mod_list) + total_modcmd
-    + ALIGN_UP (sizeof(PACKAGE_STRING), 4) 
+    + ALIGN_UP (sizeof(PACKAGE_STRING), 4)
     + grub_multiboot_get_mmap_count () * sizeof (struct multiboot_mmap_entry)
     + elf_sec_entsize * elf_sec_num
     + 256 * sizeof (struct multiboot_color)
@@ -294,11 +294,11 @@ fill_vbe_info (struct multiboot_info *mbi, grub_uint8_t *ptrorig,
 #if GRUB_MACHINE_HAS_VBE
   grub_vbe_status_t status;
   void *scratch = (void *) GRUB_MEMORY_MACHINE_SCRATCH_ADDR;
-    
+
   status = grub_vbe_bios_get_controller_info (scratch);
   if (status != GRUB_VBE_STATUS_OK)
     return grub_error (GRUB_ERR_IO, "Can't get controller info.");
-  
+
   mbi->vbe_control_info = ptrdest;
   grub_memcpy (ptrorig, scratch, sizeof (struct grub_vbe_info_block));
   ptrorig += sizeof (struct grub_vbe_info_block);
@@ -307,7 +307,7 @@ fill_vbe_info (struct multiboot_info *mbi, grub_uint8_t *ptrorig,
   mbi->vbe_control_info = 0;
 #endif
 
-#if GRUB_MACHINE_HAS_VBE  
+#if GRUB_MACHINE_HAS_VBE
   status = grub_vbe_bios_get_mode (scratch);
   vbe_mode = *(grub_uint32_t *) scratch;
   if (status != GRUB_VBE_STATUS_OK)
@@ -329,7 +329,7 @@ fill_vbe_info (struct multiboot_info *mbi, grub_uint8_t *ptrorig,
     }
   else
     {
-#if GRUB_MACHINE_HAS_VBE  
+#if GRUB_MACHINE_HAS_VBE
       status = grub_vbe_bios_get_mode_info (vbe_mode, scratch);
       if (status != GRUB_VBE_STATUS_OK)
 	return grub_error (GRUB_ERR_IO, "can't get mode info");
@@ -340,19 +340,19 @@ fill_vbe_info (struct multiboot_info *mbi, grub_uint8_t *ptrorig,
   ptrorig += sizeof (struct grub_vbe_mode_info_block);
   ptrdest += sizeof (struct grub_vbe_mode_info_block);
 
-#if GRUB_MACHINE_HAS_VBE        
+#if GRUB_MACHINE_HAS_VBE
   grub_vbe_bios_get_pm_interface (&mbi->vbe_interface_seg,
 				  &mbi->vbe_interface_off,
 				  &mbi->vbe_interface_len);
 #endif
-  
+
   mbi->flags |= MULTIBOOT_INFO_VBE_INFO;
 
   if (fill_generic && mode_info->memory_model == GRUB_VBE_MEMORY_MODEL_TEXT)
     {
       mbi->framebuffer_addr = 0xb8000;
 
-      mbi->framebuffer_pitch = 2 * mode_info->x_resolution;	
+      mbi->framebuffer_pitch = 2 * mode_info->x_resolution;
       mbi->framebuffer_width = mode_info->x_resolution;
       mbi->framebuffer_height = mode_info->y_resolution;
 
@@ -406,7 +406,7 @@ retrieve_video_parameters (struct multiboot_info *mbi,
   mbi->framebuffer_height = mode_info.height;
 
   mbi->framebuffer_bpp = mode_info.bpp;
-      
+
   if (mode_info.mode_type & GRUB_VIDEO_MODE_TYPE_INDEX_COLOR)
     {
       struct multiboot_color *mb_palette;
@@ -457,7 +457,7 @@ grub_multiboot_make_mbi (grub_uint32_t *target)
   unsigned i;
   struct module *cur;
   grub_size_t mmap_size;
-  grub_uint8_t *ptrorig; 
+  grub_uint8_t *ptrorig;
   grub_addr_t ptrdest;
 
   grub_err_t err;
@@ -541,7 +541,7 @@ grub_multiboot_make_mbi (grub_uint32_t *target)
       mbi->mods_count = 0;
     }
 
-  mmap_size = grub_multiboot_get_mmap_count () 
+  mmap_size = grub_multiboot_get_mmap_count ()
     * sizeof (struct multiboot_mmap_entry);
   grub_fill_multiboot_mmap ((struct multiboot_mmap_entry *) ptrorig);
   mbi->mmap_length = mmap_size;
@@ -750,7 +750,7 @@ grub_multiboot_set_bootdev (void)
   if (dev)
     grub_device_close (dev);
 
-  bootdev = ((biosdev & 0xff) << 24) | ((slice & 0xff) << 16) 
+  bootdev = ((biosdev & 0xff) << 24) | ((slice & 0xff) << 16)
     | ((part & 0xff) << 8) | 0xff;
   bootdev_set = 1;
 }
diff --git a/grub-core/loader/i386/pc/chainloader.c b/grub-core/loader/i386/pc/chainloader.c
index 976fea73a..a38389999 100644
--- a/grub-core/loader/i386/pc/chainloader.c
+++ b/grub-core/loader/i386/pc/chainloader.c
@@ -57,7 +57,7 @@ typedef enum
 static grub_err_t
 grub_chainloader_boot (void)
 {
-  struct grub_relocator16_state state = { 
+  struct grub_relocator16_state state = {
     .edx = boot_drive,
     .esi = boot_part_addr,
     .ds = 0,
@@ -118,7 +118,7 @@ grub_chainloader_patch_bpb (void *bs, grub_device_t dev, grub_uint8_t dl)
 	  || (grub_le_to_cpu16 (bpb->bytes_per_sector)
 	      & (grub_le_to_cpu16 (bpb->bytes_per_sector) - 1)))
 	break;
-	  
+
       if (bpb->sectors_per_cluster == 0
 	  || (bpb->sectors_per_cluster & (bpb->sectors_per_cluster - 1)))
 	break;
@@ -243,7 +243,7 @@ grub_chainloader_cmd (const char *filename, grub_chainloader_flags_t flags)
 
   if (dev)
     grub_device_close (dev);
- 
+
   /* Ignore errors. Perhaps it's not fatal.  */
   grub_errno = GRUB_ERR_NONE;
 
diff --git a/grub-core/loader/i386/pc/freedos.c b/grub-core/loader/i386/pc/freedos.c
index aac6c9715..f2242dc51 100644
--- a/grub-core/loader/i386/pc/freedos.c
+++ b/grub-core/loader/i386/pc/freedos.c
@@ -62,7 +62,7 @@ static grub_uint32_t ebx = 0xffffffff;
 static grub_err_t
 grub_freedos_boot (void)
 {
-  struct grub_relocator16_state state = { 
+  struct grub_relocator16_state state = {
     .cs = GRUB_FREEDOS_SEGMENT,
     .ip = 0,
 
@@ -161,7 +161,7 @@ grub_cmd_freedos (grub_command_t cmd __attribute__ ((unused)),
   if (grub_file_read (file, kernelsys, kernelsyssize)
       != (grub_ssize_t) kernelsyssize)
     goto fail;
- 
+
   grub_loader_set (grub_freedos_boot, grub_freedos_unload, 1);
   return GRUB_ERR_NONE;
 
diff --git a/grub-core/loader/i386/pc/linux.c b/grub-core/loader/i386/pc/linux.c
index 2a2995201..b670b6532 100644
--- a/grub-core/loader/i386/pc/linux.c
+++ b/grub-core/loader/i386/pc/linux.c
@@ -67,7 +67,7 @@ grub_linux16_boot (void)
   grub_video_set_mode ("text", 0, 0);
 
   grub_stop_floppy ();
-  
+
   return grub_relocator16_boot (relocator, state);
 }
 
diff --git a/grub-core/loader/i386/pc/ntldr.c b/grub-core/loader/i386/pc/ntldr.c
index f0d74145b..2b1dec62a 100644
--- a/grub-core/loader/i386/pc/ntldr.c
+++ b/grub-core/loader/i386/pc/ntldr.c
@@ -45,7 +45,7 @@ static grub_uint32_t edx = 0xffffffff;
 static grub_err_t
 grub_ntldr_boot (void)
 {
-  struct grub_relocator16_state state = { 
+  struct grub_relocator16_state state = {
     .cs = GRUB_NTLDR_SEGMENT,
     .ip = 0,
     .ds = 0,
@@ -133,7 +133,7 @@ grub_cmd_ntldr (grub_command_t cmd __attribute__ ((unused)),
   if (grub_file_read (file, ntldr, ntldrsize)
       != (grub_ssize_t) ntldrsize)
     goto fail;
- 
+
   grub_loader_set (grub_ntldr_boot, grub_ntldr_unload, 1);
   return GRUB_ERR_NONE;
 
diff --git a/grub-core/loader/i386/pc/plan9.c b/grub-core/loader/i386/pc/plan9.c
index 37550155d..960e866f4 100644
--- a/grub-core/loader/i386/pc/plan9.c
+++ b/grub-core/loader/i386/pc/plan9.c
@@ -56,7 +56,7 @@ static const struct grub_arg_option options[] =
 	means that the GRUBDEVICE and PLAN9DEVICE are
 	actually the same device, just named differently
 	in OS and GRUB.  */
-     N_("Override guessed mapping of Plan9 devices."), 
+     N_("Override guessed mapping of Plan9 devices."),
      N_("GRUBDEVICE=PLAN9DEVICE"),
      ARG_TYPE_STRING},
     {0, 0, 0, 0, 0, 0}
@@ -78,7 +78,7 @@ struct grub_plan9_header
 static grub_err_t
 grub_plan9_boot (void)
 {
-  struct grub_relocator32_state state = { 
+  struct grub_relocator32_state state = {
     .eax = 0,
     .eip = eip,
     .ebx = 0,
@@ -122,7 +122,7 @@ static const char prefixes[5][10] = {
 
 #include <grub/err.h>
 
-static inline grub_err_t 
+static inline grub_err_t
 grub_extend_alloc (grub_size_t sz, grub_size_t *allocated, char **ptr)
 {
   void *n;
@@ -302,7 +302,7 @@ fill_disk (const char *name, void *data)
 	    grub_device_close (dev);
 	    return 0;
 	  }
-	
+
 	/* if it's the disk the kernel is loaded from we need to name
 	   it nevertheless.  */
 	plan9name = grub_strdup ("sdZ0");
@@ -331,7 +331,7 @@ fill_disk (const char *name, void *data)
 	    plan9name = grub_xasprintf ("sd%c%d", 'C' + unit / 2, unit % 2);
 	    break;
 	  }
-	
+
 	/* FIXME: how does Plan9 number controllers?
 	   We probably need save the SCSI devices and sort them  */
 	plan9name
diff --git a/grub-core/loader/i386/pc/pxechainloader.c b/grub-core/loader/i386/pc/pxechainloader.c
index acb061169..df4f7c60b 100644
--- a/grub-core/loader/i386/pc/pxechainloader.c
+++ b/grub-core/loader/i386/pc/pxechainloader.c
@@ -46,7 +46,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 static grub_err_t
 grub_pxechain_boot (void)
 {
-  struct grub_relocator16_state state = { 
+  struct grub_relocator16_state state = {
     .cs = 0,
     .ip = 0x7c00,
     .ds = 0,
@@ -138,7 +138,7 @@ grub_cmd_pxechain (grub_command_t cmd __attribute__ ((unused)),
 
   if (grub_file_read (file, image, imagesize) != (grub_ssize_t) imagesize)
     goto fail;
- 
+
   grub_loader_set (grub_pxechain_boot, grub_pxechain_unload,
 		   GRUB_LOADER_FLAG_NORETURN | GRUB_LOADER_FLAG_PXE_NOT_UNLOAD);
   return GRUB_ERR_NONE;
diff --git a/grub-core/loader/i386/pc/truecrypt.c b/grub-core/loader/i386/pc/truecrypt.c
index cbeeec7be..bae1ad031 100644
--- a/grub-core/loader/i386/pc/truecrypt.c
+++ b/grub-core/loader/i386/pc/truecrypt.c
@@ -48,7 +48,7 @@ static grub_err_t
 grub_truecrypt_boot (void)
 {
   grub_uint16_t segment = destaddr >> 4;
-  struct grub_relocator16_state state = { 
+  struct grub_relocator16_state state = {
     .cs = segment,
     .ds = segment,
     .es = segment,
@@ -194,7 +194,7 @@ grub_cmd_truecrypt (grub_command_t cmd __attribute__ ((unused)),
   grub_memset ((char *) truecrypt + truecryptsize + 0x100,
 	       0, truecryptmemsize - truecryptsize - 0x100);
   sp = truecryptmemsize - 4;
- 
+
   grub_loader_set (grub_truecrypt_boot, grub_truecrypt_unload, 1);
 
   grub_free (uncompressed);
diff --git a/grub-core/loader/i386/xnu.c b/grub-core/loader/i386/xnu.c
index a70093607..c516d0c6c 100644
--- a/grub-core/loader/i386/xnu.c
+++ b/grub-core/loader/i386/xnu.c
@@ -812,7 +812,7 @@ grub_xnu_boot_resume (void)
   state.eip = grub_xnu_entry_point;
   state.eax = grub_xnu_arg1;
 
-  return grub_relocator32_boot (grub_xnu_relocator, state, 0); 
+  return grub_relocator32_boot (grub_xnu_relocator, state, 0);
 }
 
 /* Setup video for xnu. */
@@ -912,7 +912,7 @@ grub_xnu_set_video (struct grub_xnu_boot_params_common *params)
   params->lfb_line_len = mode_info.pitch;
 
   params->lfb_base = (grub_addr_t) framebuffer;
-  params->lfb_mode = bitmap ? GRUB_XNU_VIDEO_SPLASH 
+  params->lfb_mode = bitmap ? GRUB_XNU_VIDEO_SPLASH
     : GRUB_XNU_VIDEO_TEXT_IN_VIDEO;
 
   return GRUB_ERR_NONE;
@@ -1069,7 +1069,7 @@ grub_xnu_boot (void)
   if (v2)
     bootparams->v2.efi_system_table = (grub_addr_t) grub_autoefi_system_table;
   else
-    bootparams->v1.efi_system_table = (grub_addr_t) grub_autoefi_system_table;  
+    bootparams->v1.efi_system_table = (grub_addr_t) grub_autoefi_system_table;
 
   firstruntimepage = (((grub_addr_t) grub_xnu_heap_target_start
 		       + grub_xnu_heap_size + GRUB_XNU_PAGESIZE - 1)
diff --git a/grub-core/loader/ia64/efi/linux.c b/grub-core/loader/ia64/efi/linux.c
index 7987fd1ba..41266109e 100644
--- a/grub-core/loader/ia64/efi/linux.c
+++ b/grub-core/loader/ia64/efi/linux.c
@@ -106,7 +106,7 @@ query_fpswa (void)
   grub_efi_boot_services_t *bs;
   grub_efi_status_t status;
   grub_efi_uintn_t size;
-  static const grub_efi_guid_t fpswa_protocol = 
+  static const grub_efi_guid_t fpswa_protocol =
     { 0xc41b6531, 0x97b9, 0x11d3,
       {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} };
 
@@ -114,7 +114,7 @@ query_fpswa (void)
     return;
 
   size = sizeof(grub_efi_handle_t);
-  
+
   bs = grub_efi_system_table->boot_services;
   status = bs->locate_handle (GRUB_EFI_BY_PROTOCOL,
 			      (void *) &fpswa_protocol,
@@ -131,7 +131,7 @@ query_fpswa (void)
       grub_printf ("%s\n",
 		   _("FPSWA protocol wasn't able to find the interface"));
       return;
-    } 
+    }
 }
 
 static void
@@ -188,7 +188,7 @@ allocate_pages (grub_uint64_t align, grub_uint64_t size_pages,
     }
 
   mmap_end = NEXT_MEMORY_DESCRIPTOR (mmap, tmp_mmap_size);
-  
+
   /* First, find free pages for the real mode code
      and the memory map buffer.  */
   for (desc = mmap;
@@ -240,7 +240,7 @@ set_boot_param_console (void)
 {
   grub_efi_simple_text_output_interface_t *conout;
   grub_efi_uintn_t cols, rows;
-  
+
   conout = grub_efi_system_table->con_out;
   if (conout->query_mode (conout, conout->mode->mode, &cols, &rows)
       != GRUB_EFI_SUCCESS)
@@ -250,7 +250,7 @@ set_boot_param_console (void)
 		"Console info: cols=%lu rows=%lu x=%u y=%u\n",
 		cols, rows,
 		conout->mode->cursor_column, conout->mode->cursor_row);
-  
+
   boot_param->console_info.num_cols = cols;
   boot_param->console_info.num_rows = rows;
   boot_param->console_info.orig_x = conout->mode->cursor_column;
@@ -300,7 +300,7 @@ grub_linux_boot (void)
 
   /* See you next boot.  */
   asm volatile ("mov r28=%1; br.sptk.few %0" :: "b"(entry),"r"(boot_param));
-  
+
   /* Never reach here.  */
   return GRUB_ERR_NONE;
 }
@@ -411,7 +411,7 @@ grub_load_elf64 (grub_file_t file, void *buffer, const char *filename)
 			"off=%lx flags=%x]\n",
 			phdr->p_paddr, phdr->p_paddr + reloc_offset,
 			phdr->p_memsz, phdr->p_offset, phdr->p_flags);
-	  
+
 	  if (grub_file_seek (file, phdr->p_offset) == (grub_off_t)-1)
 	    return grub_errno;
 
@@ -424,7 +424,7 @@ grub_load_elf64 (grub_file_t file, void *buffer, const char *filename)
 			    filename);
 	      return grub_errno;
 	    }
-	  
+
           if (phdr->p_filesz < phdr->p_memsz)
 	    grub_memset
 	      ((char *)(phdr->p_paddr + reloc_offset + phdr->p_filesz),
@@ -453,7 +453,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
   grub_dl_ref (my_mod);
 
   grub_loader_unset ();
-    
+
   if (argc == 0)
     {
       grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
@@ -507,7 +507,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
 
   if (grub_verify_string (cmdline, GRUB_VERIFY_KERNEL_CMDLINE))
     goto fail;
-  
+
   boot_param->command_line = (grub_uint64_t) cmdline;
   boot_param->efi_systab = (grub_uint64_t) grub_efi_system_table;
 
@@ -539,7 +539,7 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
       grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
       goto fail;
     }
-  
+
   if (! loaded)
     {
       grub_error (GRUB_ERR_BAD_ARGUMENT, N_("you need to load the kernel first"));
@@ -559,7 +559,7 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
       grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate pages");
       goto fail;
     }
-  
+
   grub_dprintf ("linux", "[addr=0x%lx, size=0x%lx]\n",
 		(grub_uint64_t) initrd_mem, initrd_size);
 
@@ -589,7 +589,7 @@ GRUB_MOD_INIT(linux)
 {
   cmd_linux = grub_register_command ("linux", grub_cmd_linux,
 				     N_("FILE [ARGS...]"), N_("Load Linux."));
-  
+
   cmd_initrd = grub_register_command ("initrd", grub_cmd_initrd,
 				      N_("FILE"), N_("Load initrd."));
 
diff --git a/grub-core/loader/linux.c b/grub-core/loader/linux.c
index 3fe390f17..ade9b2fef 100644
--- a/grub-core/loader/linux.c
+++ b/grub-core/loader/linux.c
@@ -239,7 +239,7 @@ grub_initrd_init (int argc, char *argv[],
       free_dir (root);
       root = 0;
     }
-  
+
   return GRUB_ERR_NONE;
 
  overflow:
diff --git a/grub-core/loader/lzss.c b/grub-core/loader/lzss.c
index 532d8e4a3..2c3e4507f 100644
--- a/grub-core/loader/lzss.c
+++ b/grub-core/loader/lzss.c
@@ -31,7 +31,7 @@ grub_decompress_lzss (grub_uint8_t *dst, grub_uint8_t *dstend,
 	unsigned int  flags;
 	static unsigned char text_buf[N + F - 1];
 	grub_uint8_t *dst0 = dst;
-	
+
 	for (i = 0; i < N - F; i++) text_buf[i] = ' ';
 	r = N - F;  flags = 0;
 	for ( ; ; ) {
diff --git a/grub-core/loader/mips/linux.c b/grub-core/loader/mips/linux.c
index e4ed95921..2f912c61c 100644
--- a/grub-core/loader/mips/linux.c
+++ b/grub-core/loader/mips/linux.c
@@ -100,7 +100,7 @@ grub_linux_boot (void)
     str = (char *) (magic + 1);
     grub_strcpy (str, params);
   }
-#endif  
+#endif
 
 #ifndef GRUB_MACHINE_MIPS_QEMU_MIPS
   state.gpr[4] = linux_argc;
@@ -261,11 +261,11 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
   linux_argc++;
 #endif
   /* Main arguments.  */
-  size = (linux_argc) * sizeof (grub_uint32_t); 
+  size = (linux_argc) * sizeof (grub_uint32_t);
   /* Initrd address and size.  */
-  size += 2 * sizeof (grub_uint32_t); 
+  size += 2 * sizeof (grub_uint32_t);
   /* NULL terminator.  */
-  size += sizeof (grub_uint32_t); 
+  size += sizeof (grub_uint32_t);
 
   /* First argument is always "a0".  */
   size += ALIGN_UP (sizeof ("a0"), 4);
diff --git a/grub-core/loader/multiboot.c b/grub-core/loader/multiboot.c
index facb13f3d..94be512c4 100644
--- a/grub-core/loader/multiboot.c
+++ b/grub-core/loader/multiboot.c
@@ -238,7 +238,7 @@ GRUB_MULTIBOOT (set_console) (int console_type, int accepted_consoles,
 			      int console_req)
 {
   console_required = console_req;
-  if (!(accepted_consoles 
+  if (!(accepted_consoles
 	& (GRUB_MULTIBOOT_CONSOLE_FRAMEBUFFER
 	   | (GRUB_MACHINE_HAS_VGA_TEXT ? GRUB_MULTIBOOT_CONSOLE_EGA_TEXT : 0))))
     {
diff --git a/grub-core/loader/multiboot_elfxx.c b/grub-core/loader/multiboot_elfxx.c
index f2318e0d1..6801f0ddf 100644
--- a/grub-core/loader/multiboot_elfxx.c
+++ b/grub-core/loader/multiboot_elfxx.c
@@ -206,7 +206,7 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
     return grub_error (GRUB_ERR_BAD_OS, "entry point isn't in a segment");
 
 #if defined (__i386__) || defined (__x86_64__)
-  
+
 #elif defined (__mips)
   GRUB_MULTIBOOT (payload_eip) |= 0x80000000;
 #else
@@ -220,7 +220,7 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
       shdr = grub_calloc (ehdr->e_shnum, ehdr->e_shentsize);
       if (!shdr)
 	return grub_errno;
-      
+
       if (grub_file_seek (mld->file, ehdr->e_shoff) == (grub_off_t) -1)
 	{
 	  grub_free (shdr);
@@ -235,7 +235,7 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
 			mld->filename);
 	  return grub_errno;
 	}
-      
+
       for (shdrptr = shdr, i = 0; i < ehdr->e_shnum;
 	   shdrptr += ehdr->e_shentsize, i++)
 	{
@@ -250,7 +250,7 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
 	     so we don't care.  */
 	  if (sh->sh_addr != 0)
 	    continue;
-		      
+
 	  /* This section is empty, so we don't care.  */
 	  if (sh->sh_size == 0)
 	    continue;
diff --git a/grub-core/loader/multiboot_mbi2.c b/grub-core/loader/multiboot_mbi2.c
index 9a943d7bd..6d680d671 100644
--- a/grub-core/loader/multiboot_mbi2.c
+++ b/grub-core/loader/multiboot_mbi2.c
@@ -196,7 +196,7 @@ grub_multiboot2_load (grub_file_t file, const char *filename)
 	      }
 	  break;
 	}
-	       
+
       case MULTIBOOT_HEADER_TAG_ADDRESS:
 	addr_tag = (struct multiboot_header_tag_address *) tag;
 	break;
@@ -274,7 +274,7 @@ grub_multiboot2_load (grub_file_t file, const char *filename)
       return grub_error (GRUB_ERR_UNKNOWN_OS,
 			 "load address tag without entry address tag");
     }
- 
+
   if (addr_tag)
     {
       grub_uint64_t load_addr = (addr_tag->load_addr + 1)
@@ -492,7 +492,7 @@ grub_fill_multiboot_mmap (struct multiboot_tag_mmap *tag)
 
   tag->type = MULTIBOOT_TAG_TYPE_MMAP;
   tag->size = sizeof (struct multiboot_tag_mmap)
-    + sizeof (struct multiboot_mmap_entry) * grub_multiboot2_get_mmap_count (); 
+    + sizeof (struct multiboot_mmap_entry) * grub_multiboot2_get_mmap_count ();
   tag->entry_size = sizeof (struct multiboot_mmap_entry);
   tag->entry_version = 0;
 
@@ -508,14 +508,14 @@ fill_vbe_tag (struct multiboot_tag_vbe *tag)
 
   tag->type = MULTIBOOT_TAG_TYPE_VBE;
   tag->size = 0;
-    
+
   status = grub_vbe_bios_get_controller_info (scratch);
   if (status != GRUB_VBE_STATUS_OK)
     return;
-  
+
   grub_memcpy (&tag->vbe_control_info, scratch,
 	       sizeof (struct grub_vbe_info_block));
-  
+
   status = grub_vbe_bios_get_mode (scratch);
   tag->vbe_mode = *(grub_uint32_t *) scratch;
   if (status != GRUB_VBE_STATUS_OK)
@@ -538,7 +538,7 @@ fill_vbe_tag (struct multiboot_tag_vbe *tag)
 	return;
       grub_memcpy (&tag->vbe_mode_info, scratch,
 		   sizeof (struct grub_vbe_mode_info_block));
-    }      
+    }
   grub_vbe_bios_get_pm_interface (&tag->vbe_interface_seg,
 				  &tag->vbe_interface_off,
 				  &tag->vbe_interface_len);
@@ -616,13 +616,13 @@ retrieve_video_parameters (grub_properly_aligned_t **ptrorig)
 	  tag->common.size = 0;
 
 	  tag->common.framebuffer_addr = 0xb8000;
-	  
-	  tag->common.framebuffer_pitch = 2 * vbe_mode_info.x_resolution;	
+
+	  tag->common.framebuffer_pitch = 2 * vbe_mode_info.x_resolution;
 	  tag->common.framebuffer_width = vbe_mode_info.x_resolution;
 	  tag->common.framebuffer_height = vbe_mode_info.y_resolution;
 
 	  tag->common.framebuffer_bpp = 16;
-	  
+
 	  tag->common.framebuffer_type = MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT;
 	  tag->common.size = sizeof (tag->common);
 	  tag->common.reserved = 0;
@@ -664,7 +664,7 @@ retrieve_video_parameters (grub_properly_aligned_t **ptrorig)
   tag->common.framebuffer_bpp = mode_info.bpp;
 
   tag->common.reserved = 0;
-      
+
   if (mode_info.mode_type & GRUB_VIDEO_MODE_TYPE_INDEX_COLOR)
     {
       unsigned i;
@@ -748,7 +748,7 @@ grub_multiboot2_make_mbi (grub_uint32_t *target)
   {
     struct multiboot_tag_string *tag = (struct multiboot_tag_string *) ptrorig;
     tag->type = MULTIBOOT_TAG_TYPE_CMDLINE;
-    tag->size = sizeof (struct multiboot_tag_string) + cmdline_size; 
+    tag->size = sizeof (struct multiboot_tag_string) + cmdline_size;
     grub_memcpy (tag->string, cmdline, cmdline_size);
     ptrorig += ALIGN_UP (tag->size, MULTIBOOT_TAG_ALIGN)
        / sizeof (grub_properly_aligned_t);
@@ -757,7 +757,7 @@ grub_multiboot2_make_mbi (grub_uint32_t *target)
   {
     struct multiboot_tag_string *tag = (struct multiboot_tag_string *) ptrorig;
     tag->type = MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME;
-    tag->size = sizeof (struct multiboot_tag_string) + sizeof (PACKAGE_STRING); 
+    tag->size = sizeof (struct multiboot_tag_string) + sizeof (PACKAGE_STRING);
     grub_memcpy (tag->string, PACKAGE_STRING, sizeof (PACKAGE_STRING));
     ptrorig += ALIGN_UP (tag->size, MULTIBOOT_TAG_ALIGN)
       / sizeof (grub_properly_aligned_t);
@@ -771,7 +771,7 @@ grub_multiboot2_make_mbi (grub_uint32_t *target)
 	struct multiboot_tag_apm *tag = (struct multiboot_tag_apm *) ptrorig;
 
 	tag->type = MULTIBOOT_TAG_TYPE_APM;
-	tag->size = sizeof (struct multiboot_tag_apm); 
+	tag->size = sizeof (struct multiboot_tag_apm);
 
 	tag->cseg = info.cseg;
 	tag->offset = info.offset;
@@ -864,7 +864,7 @@ grub_multiboot2_make_mbi (grub_uint32_t *target)
       struct multiboot_tag_bootdev *tag
 	= (struct multiboot_tag_bootdev *) ptrorig;
       tag->type = MULTIBOOT_TAG_TYPE_BOOTDEV;
-      tag->size = sizeof (struct multiboot_tag_bootdev); 
+      tag->size = sizeof (struct multiboot_tag_bootdev);
 
       tag->biosdev = biosdev;
       tag->slice = slice;
diff --git a/grub-core/loader/xnu.c b/grub-core/loader/xnu.c
index 1c0cf6a43..4cca55df9 100644
--- a/grub-core/loader/xnu.c
+++ b/grub-core/loader/xnu.c
@@ -64,7 +64,7 @@ grub_xnu_heap_malloc (int size, void **src, grub_addr_t *target)
 
   if (grub_add (grub_xnu_heap_target_start, grub_xnu_heap_size, &tgt))
     return GRUB_ERR_OUT_OF_RANGE;
-  
+
   err = grub_relocator_alloc_chunk_addr (grub_xnu_relocator, &ch, tgt, size);
   if (err)
     return err;
@@ -1399,10 +1399,10 @@ grub_xnu_fill_devicetree (void)
     nextdot = curdot + grub_strlen (curdot) + 1;
 
     name = grub_realloc (name, nextdot - curdot + 1);
-   
+
     if (!name)
       return grub_errno;
-   
+
     unescape (name, curdot, nextdot, &len);
     name[len] = 0;
 
@@ -1410,11 +1410,11 @@ grub_xnu_fill_devicetree (void)
     grub_free (name);
     if (!curvalue)
       return grub_errno;
-   
+
     data = grub_malloc (grub_strlen (var->value) + 1);
     if (!data)
       return grub_errno;
-   
+
     unescape (data, var->value, var->value + grub_strlen (var->value),
 	      &len);
     curvalue->datasize = len;
-- 
2.36.1

